# MPU6050 IMU系统架构详解

## 文档概述

本文档详细说明了STM32底盘项目中MPU6050惯性测量单元（IMU）的完整工作机制，包括硬件连接、驱动层设计、DMP（Digital Motion Processor）算法原理以及应用层接口。

---

## 目录

1. [系统架构概览](#1-系统架构概览)
2. [硬件层](#2-硬件层)
3. [驱动层](#3-驱动层)
4. [DMP算法层](#4-dmp算法层)
5. [应用封装层](#5-应用封装层)
6. [数据流程](#6-数据流程)

---

## 1. 系统架构概览

### 1.1 分层架构

本项目采用三层架构设计，实现了清晰的职责分离：

```
┌─────────────────────────────────────────────────────────┐
│  应用层: USER/IMU (imu_data.c/h)                        │
│  - 统一的数据接口                                         │
│  - 数据格式转换和精度处理                                │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│  算法层: USER/MPU6050/eMPL (InvenSense官方库)           │
│  - DMP固件加载                                           │
│  - 传感器数据融合                                        │
│  - 姿态解算（四元数→欧拉角）                             │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│  驱动层: USER/MPU6050 (mpu6050.c/h + mpuiic.c/h)        │
│  - MPU6050寄存器操作                                     │
│  - I2C通信协议实现                                       │
│  - 基础初始化配置                                        │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│  硬件层: MPU6050                                         │
│  - 3轴陀螺仪                                             │
│  - 3轴加速度计                                           │
│  - DMP处理器                                             │
└─────────────────────────────────────────────────────────┘
```

### 1.2 目录结构

```
USER/
├── IMU/
│   ├── imu_data.c         # IMU应用层封装
│   └── imu_data.h
├── MPU6050/
│   ├── mpu6050.c          # MPU6050基础驱动
│   ├── mpu6050.h          # 寄存器定义和函数声明
│   ├── mpuiic.c           # I2C通信实现（GPIO模拟）
│   ├── mpuiic.h
│   └── eMPL/              # InvenSense官方运动处理库
│       ├── inv_mpu.c      # MPU驱动核心（DMP初始化/数据获取）
│       ├── inv_mpu.h
│       ├── inv_mpu_dmp_motion_driver.c  # DMP功能接口
│       ├── inv_mpu_dmp_motion_driver.h
│       ├── dmpKey.h       # DMP固件密钥
│       └── dmpmap.h       # DMP内存映射
```

---

## 2. 硬件层

### 2.1 MPU6050硬件特性

MPU6050是一款集成了3轴陀螺仪和3轴加速度计的6轴运动处理组件：

- **陀螺仪**：测量角速度，量程±2000dps（度/秒）
- **加速度计**：测量线性加速度，量程±2G
- **DMP**：内置数字运动处理器，可独立运行传感器融合算法
- **I2C接口**：用于与MCU通信
- **FIFO**：1024字节缓冲区，用于存储传感器数据

### 2.2 硬件连接

| MPU6050引脚 | STM32引脚 | 功能 | 说明 |
|------------|----------|------|-----|
| VCC | 3.3V | 电源 | 3.3V供电 |
| GND | GND | 地 | 地线 |
| SCL | PB12 | I2C时钟 | GPIO模拟I2C |
| SDA | PB13 | I2C数据 | GPIO模拟I2C |
| AD0 | GND | 地址选择 | 接地→I2C地址0x68 |
| INT | PC12 | 中断引脚 | EXTI中断输入，下降沿触发 |

**I2C地址**：0x68（7位地址），8位读写地址为0xD0/0xD1

### 2.3 坐标系定义

MPU6050采用右手坐标系：
- **X轴**：指向设备前方
- **Y轴**：指向设备右方
- **Z轴**：垂直于设备平面向上

**陀螺仪输出**：角速度（度/秒），右手螺旋定则
**加速度计输出**：线性加速度（G），重力加速度为正值

---

## 3. 驱动层

驱动层负责与MPU6050硬件直接通信，包括I2C通信实现和寄存器操作。

### 3.1 I2C通信层 (mpuiic.c/h)

使用GPIO模拟I2C协议，而非STM32硬件I2C，提高了兼容性。

#### 3.1.1 I2C初始化

```c
void MPU_IIC_Init(void)
```

**功能**：初始化I2C总线引脚（PB12-SCL, PB13-SDA）
**实现**：
- 配置GPIO为开漏输出模式
- 设置SCL和SDA为高电平（空闲状态）

#### 3.1.2 I2C基本操作

```c
void MPU_IIC_Start(void)   // 产生I2C起始信号
void MPU_IIC_Stop(void)    // 产生I2C停止信号
void MPU_IIC_Send_Byte(uint8_t dat)  // 发送一个字节
uint8_t MPU_IIC_Read_Byte(uint8_t ack)  // 接收一个字节
uint8_t MPU_IIC_Wait_Ack(void)  // 等待ACK信号
```

**I2C时序**：
```
起始信号: SDA高→低时，SCL保持高
停止信号: SDA低→高时，SCL保持高
```

### 3.2 MPU6050基础驱动 (mpu6050.c/h)

#### 3.2.1 寄存器地址定义

```c
#define MPU_PWR_MGMT1_REG    0x6B    // 电源管理寄存器1
#define MPU_PWR_MGMT2_REG    0x6C    // 电源管理寄存器2
#define MPU_GYRO_CFG_REG     0x1B    // 陀螺仪配置寄存器
#define MPU_ACCEL_CFG_REG    0x1C    // 加速度计配置寄存器
#define MPU_SAMPLE_RATE_REG  0x19    // 采样率分频器
#define MPU_CFG_REG          0x1A    // 配置寄存器（数字低通滤波器）
#define MPU_FIFO_EN_REG      0x23    // FIFO使能寄存器
#define MPU_INT_EN_REG       0x38    // 中断使能寄存器
#define MPU_USER_CTRL_REG    0x6A    // 用户控制寄存器
#define MPU_DEVICE_ID_REG    0x75    // 器件ID寄存器
```

#### 3.2.2 MPU6050基础初始化

```c
uint8_t MPU_Init(void)
```

**功能**：初始化MPU6050，配置传感器参数

**详细步骤**：

| 步骤 | 操作 | 寄存器 | 值 | 原因 |
|-----|------|--------|-----|------|
| 1 | 初始化I2C总线 | - | - | 建立通信基础 |
| 2 | 复位MPU6050 | PWR_MGMT1_REG | 0x80 | 软复位，清除所有配置 |
| 3 | 延时等待 | - | 100ms | 确保复位完成 |
| 4 | 唤醒MPU6050 | PWR_MGMT1_REG | 0x00 | 退出睡眠模式 |
| 5 | 配置陀螺仪量程 | GYRO_CFG_REG | 0x18 | ±2000dps（最灵敏） |
| 6 | 配置加速度计量程 | ACCEL_CFG_REG | 0x00 | ±2G（最灵敏） |
| 7 | 设置采样率 | SAMPLE_RATE_REG | 9 | 100Hz (1000/(9+1)=100Hz) |
| 8 | 配置低通滤波器 | CFG_REG | 4 | 截止频率约42Hz |
| 9 | 配置DMP中断 | INT_EN_REG | 0x02 | 使能DMP数据就绪中断 |
| 10 | 关闭I2C主模式 | USER_CTRL_REG | 0x00 | 不使用I2C主控功能 |
| 11 | 关闭FIFO | FIFO_EN_REG | 0x00 | 初始不使用FIFO |
| 12 | 配置中断引脚 | INTBP_CFG_REG | 0x80 | INT引脚低电平有效 |
| 13 | 读取器件ID | DEVICE_ID_REG | - | 验证通信正常（应为0x68） |
| 14 | 设置时钟源 | PWR_MGMT1_REG | 0x01 | PLL，X轴陀螺仪为参考 |
| 15 | 使能传感器 | PWR_MGMT2_REG | 0x00 | 加速度计和陀螺仪都工作 |

**量程配置说明**：

**陀螺仪** (GYRO_CFG_REG):
- 0x18 = 00011000 → FS_SEL = 11 → ±2000dps
- 灵敏度：16.4 LSB/(°/s)
- 量程越大，灵敏度越低；本项目选择最大量程以适应高速运动

**加速度计** (ACCEL_CFG_REG):
- 0x00 = 00000000 → AFS_SEL = 00 → ±2G
- 灵敏度：16384 LSB/G
- 小量程提供更高精度，适合底盘姿态测量

**采样率计算**：
```
基础采样率 = 陀螺仪输出率 / (1 + SMPLRT_DIV)
           = 1000Hz / (1 + 9)
           = 100Hz
```

**注意**：此设置与DMP输出速率保持一致（DEFAULT_MPU_HZ = 100）

实际DMP输出率 = DEFAULT_MPU_HZ = 100Hz（见 inv_mpu.h）

**数字低通滤波器** (CFG_REG = 4):
- 截止频率：42Hz
- 作用：滤除高频噪声，提高数据稳定性

#### 3.2.3 数据读取函数

**陀螺仪数据**：
```c
uint8_t MPU_Get_Gyroscope(short *gx, short *gy, short *gz)
```
- 从寄存器0x43-0x48读取6字节数据
- 返回原始ADC值（带符号16位整数）
- 量程：±32767对应±2000dps

**加速度计数据**：
```c
uint8_t MPU_Get_Accelerometer(short *ax, short *ay, short *az)
```
- 从寄存器0x3B-0x40读取6字节数据
- 返回原始ADC值（带符号16位整数）
- 量程：±32767对应±2G

**温度数据**：
```c
short MPU_Get_Temperature(void)
```
- 从寄存器0x41-0x42读取2字节数据
- 转换公式：温度(°C) = 36.53 + raw/340
- 返回值放大100倍

#### 3.2.4 I2C读写函数

```c
uint8_t MPU_Write_Byte(uint8_t reg, uint8_t data)
```
- 向指定寄存器写入1字节数据

```c
uint8_t MPU_Read_Byte(uint8_t reg)
```
- 从指定寄存器读取1字节数据

```c
uint8_t MPU_Write_Len(uint8_t addr, uint8_t reg, uint8_t len, uint8_t *buf)
```
- 连续写入多字节数据

```c
uint8_t MPU_Read_Len(uint8_t addr, uint8_t reg, uint8_t len, uint8_t *buf)
```
- 连续读取多字节数据
- 自动递增寄存器地址

---

## 4. DMP算法层

### 4.1 eMPL库简介

**eMPL (embedded Motion Processing Library)** 是InvenSense官方提供的嵌入式运动处理库，是MPU6050的核心价值所在。

**核心功能**：
1. **DMP固件管理**：加载、配置和控制MPU6050内部的DMP处理器
2. **传感器融合**：将6轴传感器数据融合为姿态信息
3. **姿态解算**：输出四元数（Quaternion），可转换为欧拉角
4. **高级算法**：
   - 陀螺仪零偏自动校准
   - 点击检测（Tap Detection）
   - Android方向识别
   - 计步器（Pedometer）
   - 运动检测

### 4.2 DMP工作原理

#### 4.2.1 什么是DMP？

DMP（Digital Motion Processor）是MPU6050内部的一个独立处理器，具有以下特点：

**硬件优势**：
- **独立运行**：不占用MCU资源，自主完成传感器融合
- **低延迟**：直接访问传感器数据，无需I2C传输延迟
- **低功耗**：专用硬件优化算法，功耗低于MCU软件计算
- **高精度**：内置校准算法，提供工厂级精度

**算法流程**：
```
原始传感器数据 → DMP处理 → 融合输出
     ↓              ↓            ↓
  陀螺仪       数据融合      四元数
  加速度计     噪声滤波      欧拉角
  (磁力计)     零偏校准      线性加速度
```

#### 4.2.2 四元数与欧拉角

**四元数（Quaternion）**：
- 表示旋转的数学工具，避免万向锁问题
- 格式：q = [q0, q1, q2, q3] = [w, x, y, z]
- DMP输出格式：q30定点数（2^30 = 1073741824）

**欧拉角（Euler Angle）**：
- Pitch（俯仰角）：绕Y轴旋转，范围[-90°, +90°]
- Roll（横滚角）：绕X轴旋转，范围[-180°, +180°]
- Yaw（航向角）：绕Z轴旋转，范围[-180°, +180°]

**转换公式**：
```c
// 四元数归一化
q0 = quat[0] / 1073741824.0f;
q1 = quat[1] / 1073741824.0f;
q2 = quat[2] / 1073741824.0f;
q3 = quat[3] / 1073741824.0f;

// 转换为欧拉角
pitch = asin(-2*q1*q3 + 2*q0*q2) * 57.3;  // 俯仰角
roll  = atan2(2*q2*q3 + 2*q0*q1, -2*q1*q1 - 2*q2*q2 + 1) * 57.3;  // 横滚角
yaw   = atan2(2*(q1*q2 + q0*q3), q0*q0 + q1*q1 - q2*q2 - q3*q3) * 57.3;  // 航向角
```

### 4.3 DMP初始化详解

```c
uint8_t mpu_dmp_init(void)
```

这是DMP工作的核心初始化函数，每一步都有其重要作用。

#### 步骤1：I2C总线初始化

```c
MPU_IIC_Init();
```

**原因**：建立与MPU6050的通信基础，必须首先完成。

#### 步骤2：MPU6050硬件初始化

```c
if (mpu_init() == 0)
```

**mpu_init()内部操作**：
1. 验证器件ID（WHO_AM_I寄存器）
2. 复位MPU6050
3. 唤醒设备
4. 配置基本参数

**返回值**：0表示成功，非0表示失败

**原因**：
- 验证硬件连接是否正常
- 恢复到已知的初始状态
- 准备好硬件环境供DMP使用

#### 步骤3：启用所需传感器

```c
res = mpu_set_sensors(INV_XYZ_GYRO | INV_XYZ_ACCEL);
```

**参数说明**：
- `INV_XYZ_GYRO`：启用3轴陀螺仪
- `INV_XYZ_ACCEL`：启用3轴加速度计
- 位或运算表示同时启用

**原因**：
- DMP需要6轴数据进行姿态解算
- 明确告诉DMP哪些传感器数据可用
- 未启用的传感器不会被DMP处理

**内部机制**：
- 写入PWR_MGMT2寄存器
- 唤醒对应的传感器轴
- 配置传感器的时钟源

#### 步骤4：配置FIFO缓冲区

```c
res = mpu_configure_fifo(INV_XYZ_GYRO | INV_XYZ_ACCEL);
```

**功能**：设置哪些传感器的数据写入FIFO

**FIFO作用**：
- **缓冲数据**：传感器数据先存入FIFO，MCU按需批量读取
- **减轻CPU负担**：无需频繁的中断或轮询
- **数据同步**：确保所有传感器数据时间戳一致

**配置原理**：
- FIFO_EN寄存器控制哪些数据写入FIFO
- 启用陀螺仪和加速度计后，它们的原始数据会自动写入FIFO
- DMP处理后的四元数也会写入FIFO

**原因**：
- DMP使用FIFO作为数据输出通道
- 配置正确的FIFO源才能获取需要的数据
- 避免FIFO溢出

#### 步骤5：设置采样率

```c
res = mpu_set_sample_rate(DEFAULT_MPU_HZ);  // DEFAULT_MPU_HZ = 100
```

**功能**：设置DMP的输出频率为100Hz

**采样率选择考虑**：
- **100Hz**：本项目使用，每10ms输出一次姿态数据
- **权衡**：
  - 过高：增加CPU负担，数据冗余
  - 过低：响应慢，丢失快速运动信息

**底盘控制场景**：
- 100Hz足够捕捉底盘的运动变化
- 与控制周期（一般10-20ms）匹配

**原因**：
- DMP需要知道以什么频率输出姿态数据
- 采样率影响FIFO的填充速度
- 与后续的DMP输出速率配置协调

#### 步骤6：加载DMP固件 ⭐核心步骤

```c
res = dmp_load_motion_driver_firmware();
```

**这是最关键的一步！**

**功能**：将DMP固件程序加载到MPU6050的内部存储器

**固件来源**：
- eMPL库中预编译的二进制固件
- 通常存储在代码的Flash数组中

**加载过程**：
1. 通过I2C写入MPU6050的DMP内存
2. 使用mpu_write_mem()函数批量写入
3. 固件大小约几KB，需要分批传输
4. 加载完成后设置固件起始地址

**为什么需要加载固件？**
- **出厂无固件**：MPU6050出厂时DMP内存为空
- **可编程性**：DMP是可编程的处理器，需要加载程序
- **功能更新**：可以升级固件获得新功能
- **InvenSense算法**：固件包含InvenSense专利的融合算法

**错误码4**：如果此步骤失败，返回4，表示固件加载失败

**原因**：
- DMP本质上是一个嵌入式处理器，需要程序才能工作
- 固件包含了传感器融合、姿态解算的核心算法
- 这是DMP能工作的前提条件

#### 步骤7：设置传感器方向矩阵

```c
res = dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));
```

**方向矩阵定义**：
```c
static signed char gyro_orientation[9] = {
    1, 0, 0,  // X轴方向
    0, 1, 0,  // Y轴方向
    0, 0, 1   // Z轴方向
};
```

**功能**：告诉DMP传感器坐标系与机身坐标系的关系

**坐标系对齐**：
- **传感器坐标系**：MPU6050芯片的物理方向
- **机身坐标系**：底盘定义的前后左右方向
- **可能不一致**：芯片可能以任意方向安装在底盘上

**单位矩阵的含义**：
- 表示传感器坐标系与机身坐标系完全一致
- X、Y、Z轴一一对应，无需旋转
- 如果芯片旋转安装，需要调整此矩阵

**矩阵格式**：
```
| Xx Xy Xz |   传感器X轴在机身坐标系中的表示
| Yx Yy Yz |   传感器Y轴在机身坐标系中的表示
| Zx Zy Zz |   传感器Z轴在机身坐标系中的表示
```

**转换标量**：
- `inv_orientation_matrix_to_scalar()`将矩阵转换为标量值
- 标量用于快速索引预定义的旋转配置

**原因**：
- 确保输出的姿态角符合机身坐标系定义
- 如果方向设置错误，Pitch/Roll/Yaw会混淆或反向
- 对于精确的姿态控制，必须正确配置

#### 步骤8：启用DMP功能

```c
res = dmp_enable_feature(
    DMP_FEATURE_6X_LP_QUAT |      // 6轴低功耗四元数（必须）
    DMP_FEATURE_SEND_RAW_ACCEL |  // 发送原始加速度数据到FIFO
    DMP_FEATURE_SEND_CAL_GYRO |   // 发送校准后的陀螺仪数据到FIFO
    DMP_FEATURE_GYRO_CAL          // 陀螺仪自动校准
);
```

**功能标志详解**：

**DMP_FEATURE_6X_LP_QUAT**（最核心）：
- **6轴**：使用陀螺仪+加速度计（无磁力计）
- **LP（Low Power）**：低功耗模式
- **QUAT**：输出四元数而非欧拉角
- **作用**：这是姿态解算的主要功能
- **必须保留** ✅

**DMP_FEATURE_SEND_RAW_ACCEL**：
- FIFO中包含原始加速度计数据
- DMP处理的加速度数据
- 用于获取加速度传感器值
- **建议保留**（如需从FIFO获取）

**DMP_FEATURE_SEND_CAL_GYRO**：
- FIFO中包含校准后的陀螺仪数据
- 已去除零偏，精度高于原始数据
- **建议保留**（如需从FIFO获取）

**DMP_FEATURE_GYRO_CAL**：
- 启用陀螺仪自动校准功能
- DMP会自动计算并补偿陀螺仪零偏
- 不写入FIFO，仅内部使用
- **推荐保留** ✅（提高长期稳定性）

**已移除的功能**：
- ~~DMP_FEATURE_TAP~~：点击检测（机器人不需要）
- ~~DMP_FEATURE_ANDROID_ORIENT~~：Android方向识别（机器人不需要）

**为什么保留这些功能？**
- **6X_LP_QUAT**：必须的，提供姿态信息
- **GYRO_CAL**：提高长期稳定性，无需手动校准
- **SEND_RAW_ACCEL/SEND_CAL_GYRO**：从FIFO获取传感器数据（可选）

**性能影响**：
- 移除TAP和ANDROID_ORIENT后，DMP计算负担减少
- 如果不需要从FIFO获取原始数据，可以移除SEND_RAW_ACCEL和SEND_CAL_GYRO
- 最小配置仅需：6X_LP_QUAT + GYRO_CAL

#### 步骤9：设置DMP输出速率

```c
res = dmp_set_fifo_rate(DEFAULT_MPU_HZ);  // 100Hz
```

**功能**：设置DMP向FIFO输出数据的速率

**与采样率的关系**：
- `mpu_set_sample_rate()`：传感器采样率
- `dmp_set_fifo_rate()`：DMP输出速率
- 通常设置为相同值

**最大输出速率**：
- MPU6050的DMP最大支持200Hz
- 设置更高值会被限制在200Hz

**速率配置策略**：
```
传感器采样率 ≥ DMP输出速率 ≥ 应用读取速率
```

**本项目配置**：
- 传感器采样率：100Hz
- DMP输出速率：100Hz
- 应用读取：按需读取（通常也是100Hz）

**原因**：
- 控制姿态数据的更新频率
- 过快浪费CPU资源，过慢响应慢
- 与底盘控制周期匹配

#### 步骤10：运行自检测试

```c
res = run_self_test();
```

**功能**：运行MPU6050的内部自检程序

**自检内容**：
1. **传感器响应测试**：检查各轴是否正常响应
2. **噪声测试**：评估传感器噪声水平
3. **零偏测试**：检查静态输出是否合理
4. **量程验证**：确认量程配置正确

**测试方法**：
- 让传感器在静止状态下采集数据
- 分析统计数据（均值、标准差）
- 与预期范围比较

**通过条件**：
- 所有轴的响应在合理范围内
- 噪声水平在规格范围内
- 没有明显的故障或异常

**失败处理**：
- 返回错误码8
- 可能原因：硬件故障、焊接问题、I2C通信异常

**原因**：
- 验证硬件工作正常
- 在正式使用前发现问题
- 提供调试信息

#### 步骤11：使能DMP

```c
res = mpu_set_dmp_state(1);
```

**功能**：正式启动DMP处理器

**操作**：
- 设置USER_CTRL寄存器的DMP_EN位
- DMP开始运行之前加载的固件
- 开始处理传感器数据并输出到FIFO

**参数**：
- 1：使能DMP
- 0：禁用DMP

**使能后的状态**：
- DMP持续运行
- 传感器数据自动融合
- 姿态数据定期写入FIFO
- MCU可随时从FIFO读取

**这是最后一步**：
- 完成此步骤后，DMP开始工作
- 可以开始获取姿态数据
- 返回0表示初始化完全成功

**原因**：
- 前面的步骤都是准备工作
- 这一步真正启动DMP
- 必须在所有配置完成后才能使能

### 4.4 DMP数据获取详解

```c
uint8_t mpu_dmp_get_data(float *pitch, float *roll, float *yaw)
```

#### 步骤1：从FIFO读取数据

```c
unsigned long sensor_timestamp;
short gyro[3], accel[3], sensors;
unsigned char more;
long quat[4];

if (dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors, &more))
    return 1;
```

**函数功能**：从FIFO读取一组完整的传感器数据

**参数说明**：
- `gyro[3]`：陀螺仪数据（XYZ），单位：dps
- `accel[3]`：加速度数据（XYZ），单位：G
- `quat[4]`：四元数（q0,q1,q2,q3），q30格式
- `sensor_timestamp`：数据时间戳
- `sensors`：标志位，指示哪些数据有效
- `more`：FIFO中是否还有更多数据

**sensors标志位**：
```c
#define INV_WXYZ_QUAT       0x100  // 四元数数据有效
#define INV_XYZ_GYRO        0x70   // 陀螺仪数据有效
#define INV_XYZ_ACCEL       0x08   // 加速度数据有效
```

**数据来源**：
- **原始数据**：直接来自传感器ADC
- **校准数据**：经过零偏补偿
- **四元数**：DMP融合计算的结果

**FIFO读取机制**：
```
FIFO结构（环形缓冲区）：
┌─────────────────────────────────────┐
│ 数据包1 │ 数据包2 │ ... │ 数据包N │  │
└─────────────────────────────────────┘
  ↑读取指针  ↑写入指针

每次读取一个完整的数据包，包含所有启用的传感器数据
```

**错误处理**：
- 返回1表示FIFO读取失败
- 可能原因：FIFO为空、FIFO溢出、I2C通信错误

#### 步骤2：检查四元数数据有效性

```c
if (sensors & INV_WXYZ_QUAT) {
    // 处理四元数数据
} else {
    return 2;
}
```

**为什么需要检查？**
- FIFO中的数据包可能不包含四元数
- 如果DMP未正确配置，可能只输出原始数据
- 确保有有效的姿态数据才进行后续处理

#### 步骤3：四元数格式转换

```c
float q0 = quat[0] / 1073741824.0f;  // q30格式转浮点数
float q1 = quat[1] / 1073741824.0f;
float q2 = quat[2] / 1073741824.0f;
float q3 = quat[3] / 1073741824.0f;
```

**q30定点数格式**：
- DMP使用定点数格式以提高效率
- 1.0用2^30 = 1073741824表示
- 范围：[-2, 2)（用30位有符号整数）
- 精度：约9位小数（2^-30 ≈ 9.3e-10）

**转换原因**：
- MCU进行三角函数计算需要浮点数
- q30格式无法直接使用atan2、asin等函数

**转换公式**：
```
浮点数 = 定点数 / 2^30
```

**示例**：
- quat[0] = 1073741824 → q0 = 1.0
- quat[1] = 536870912 → q1 = 0.5
- quat[2] = 0 → q2 = 0.0

#### 步骤4：四元数转欧拉角

```c
*pitch = asin(-2*q1*q3 + 2*q0*q2) * 57.3;  // 俯仰角
*roll  = atan2(2*q2*q3 + 2*q0*q1, -2*q1*q1 - 2*q2*q2 + 1) * 57.3;  // 横滚角
*yaw   = atan2(2*(q1*q2 + q0*q3), q0*q0 + q1*q1 - q2*q2 - q3*q3) * 57.3;  // 航向角
```

**数学原理**：四元数到旋转矩阵的转换

**俯仰角（Pitch）推导**：
```
旋转矩阵中对应的元素：
R[1][2] = 2*q1*q3 + 2*q0*q2

Pitch = asin(-R[1][2])
      = asin(-2*q1*q3 - 2*q0*q2)
```

**横滚角（Roll）推导**：
```
Roll = atan2(R[1][0], R[1][1])
     = atan2(2*q2*q3 + 2*q0*q1, 1 - 2*q1*q1 - 2*q2*q2)
```

**航向角（Yaw）推导**：
```
Yaw = atan2(R[0][1], R[0][0])
    = atan2(2*q1*q2 + 2*q0*q3, q0*q0 + q1*q1 - q2*q2 - q3*q3)
```

**弧度转角度**：
- 乘以57.3（即180/π ≈ 57.2958）
- 结果单位：度

**角度范围**：
- **Pitch**：[-90°, +90°]（asin的限制）
- **Roll**：[-180°, +180°]（atan2的全范围）
- **Yaw**：[-180°, +180°]（atan2的全范围）

#### 步骤5：返回结果

```c
return 0;
```

**返回值**：
- 0：成功获取姿态数据
- 1：FIFO读取失败
- 2：无有效四元数数据

**输出数据**：
- `pitch`：俯仰角，单位：度
- `roll`：横滚角，单位：度
- `yaw`：航向角，单位：度

### 4.5 DMP数据流程图

```
┌──────────────┐
│ MPU6050硬件  │
│ - 陀螺仪     │
│ - 加速度计   │
└──────┬───────┘
       │ 原始数据
       ↓
┌──────────────┐
│ FIFO缓冲区   │
│ - 原始gyro   │
│ - 原始accel  │
└──────┬───────┘
       │ DMP读取
       ↓
┌──────────────┐
│ DMP处理器    │
│ - 传感器融合 │
│ - 姿态解算   │
│ - 零偏校准   │
└──────┬───────┘
       │ 四元数
       ↓
┌──────────────┐
│ FIFO缓冲区   │
│ - 四元数     │
│ - 校准数据   │
└──────┬───────┘
       │ MCU读取
       ↓
┌──────────────┐
│ STM32 MCU    │
│ - 格式转换   │
│ - 欧拉角计算 │
└──────────────┘
```

---

## 5. 应用封装层

### 5.1 设计目标

应用封装层（USER/IMU/imu_data.c）为上层应用提供简洁统一的接口，隐藏底层复杂性。

**主要职责**：
1. 统一初始化流程
2. 数据格式转换
3. 精度优化
4. 提供便捷的获取接口

### 5.2 初始化函数

```c
uint8_t IMU_Init(void)
```

**功能**：初始化整个IMU系统

**流程**：
```c
1. 清零所有数据变量
2. 调用MPU_Init()初始化硬件
3. 调用mpu_dmp_init()初始化DMP
4. 返回初始化结果
```

**返回值**：
- 0：成功
- 非0：失败（来自DMP初始化的错误码）

### 5.3 数据更新函数

```c
void IMU_Update(void)
```

**功能**：更新所有IMU数据

**详细流程**：

#### 5.3.1 获取DMP姿态数据

```c
while(mpu_dmp_get_data(&pitch, &roll, &yaw) != 0) {
    // 等待数据有效
}
```

**为什么使用while循环？**
- DMP需要时间处理数据
- FIFO可能暂时为空
- 确保获取到有效数据才继续

**阻塞时间**：
- 正常情况：几乎立即返回
- 异常情况：可能等待几个毫秒
- 建议：在独立线程或定时任务中调用

#### 5.3.2 获取原始传感器数据

```c
MPU_Get_Gyroscope(&gyrox, &gyroy, &gyroz);    // 陀螺仪
MPU_Get_Accelerometer(&aacx, &aacy, &aacz);  // 加速度计
```

**原始数据**：
- 直接从寄存器读取
- 未经过DMP处理
- 用于需要原始数据的场景（如振动分析）

#### 5.3.3 陀螺仪数据转换

```c
gyro[0] = (float)(gyrox * 0.001064f) * 100;
```

**转换公式推导**：

原始值 → 弧度/秒：
```
1. 原始值范围：±32767
2. 量程：±2000 dps（度/秒）
3. 转换为度/秒：gyrox * (2000 / 32767)
4. 转换为弧度/秒：度/秒 * (2π/360)
5. 合并系数：(2000 / 32767) * (2π/360) = 0.001064
```

**放大100倍的原因**：
- 保留小数精度
- 避免浮点运算（在需要整数运算的场景）
- 统一精度标准

**最终单位**：0.01 弧度/秒

**示例**：
- 原始值1000 → 1000 * 0.001064 * 100 = 106.4 → 1.064 弧度/秒

#### 5.3.4 加速度数据转换

```c
acc[0] = (float)(aacx / 32767.0f) * 2 * G * 100;
```

**转换公式**：

原始值 → G值：
```
1. 原始值范围：±32767
2. 量程：±2G
3. 归一化：aacx / 32767.0
4. 转换为G：(aacx / 32767.0) * 2
5. 转换为m/s²：G值 * 9.8
```

**宏定义G**：
```c
#define G 9.8f  // 重力加速度，单位：m/s²
```

**放大100倍**：
- 统一精度处理
- 单位：0.01 G

**示例**：
- 原始值16384（静态，Z轴向下）→ 0.5 * 2 * 9.8 * 100 = 980 → 9.8 m/s² = 1G

#### 5.3.5 欧拉角数据处理

```c
euler_angle[0] = pitch * 100;  // 俯仰角
euler_angle[1] = roll * 100;   // 横滚角
euler_angle[2] = yaw * 100;    // 航向角
```

**直接放大100倍**：
- DMP输出的单位已经是度
- 只需放大保留精度
- 单位：0.01 度

**示例**：
- pitch = 45.678° → 4567 → 实际使用时除以100得到45.67°

### 5.4 数据获取接口

#### 5.4.1 获取欧拉角

```c
void IMU_GetEulerAngle(int16_t *euler)
```

**参数**：`euler[3]`数组
- `euler[0]`：俯仰角，单位：0.01度
- `euler[1]`：横滚角，单位：0.01度
- `euler[2]`：航向角，单位：0.01度

**使用示例**：
```c
int16_t euler[3];
IMU_GetEulerAngle(euler);
float pitch = euler[0] / 100.0f;
float roll = euler[1] / 100.0f;
float yaw = euler[2] / 100.0f;
```

#### 5.4.2 获取陀螺仪数据

```c
void IMU_GetGyro(int16_t *gyro_data)
```

**参数**：`gyro_data[3]`数组
- `gyro_data[0]`：X轴角速度，单位：0.01弧度/秒
- `gyro_data[1]`：Y轴角速度，单位：0.01弧度/秒
- `gyro_data[2]`：Z轴角速度，单位：0.01弧度/秒

**使用示例**：
```c
int16_t gyro[3];
IMU_GetGyro(gyro);
float gyro_x = gyro[0] / 100.0f;  // 弧度/秒
```

#### 5.4.3 获取加速度数据

```c
void IMU_GetAccel(int16_t *acc_data)
```

**参数**：`acc_data[3]`数组
- `acc_data[0]`：X轴加速度，单位：0.01G
- `acc_data[1]`：Y轴加速度，单位：0.01G
- `acc_data[2]`：Z轴加速度，单位：0.01G

**使用示例**：
```c
int16_t acc[3];
IMU_GetAccel(acc);
float accel_z = acc[2] / 100.0f * 9.8f;  // m/s²
```

---

## 6. 数据流程

### 6.1 完整数据流

```
┌─────────────────────────────────────────────────────────┐
│                  MPU6050硬件层                           │
│  ┌──────────┐  ┌──────────┐                              │
│  │ 陀螺仪   │  │加速度计  │                              │
│  │ ±2000dps │  │  ±2G    │                              │
│  └────┬─────┘  └────┬─────┘                              │
└───────┼────────────┼─────────────────────────────────────┘
        │            │
        │ 原始ADC值  │
        ↓            ↓
┌─────────────────────────────────────────────────────────┐
│                      I2C通信层                           │
│  mpuiic.c/h - GPIO模拟I2C（PB12-SCL, PB13-SDA）        │
└─────────────────────────────────────────────────────────┘
        │
        │ 寄存器读写
        ↓
┌─────────────────────────────────────────────────────────┐
│                 MPU6050驱动层                            │
│  mpu6050.c/h - 寄存器操作、基础初始化                   │
└─────────────────────────────────────────────────────────┘
        │
        │ 传感器数据
        ↓
┌─────────────────────────────────────────────────────────┐
│                    DMP处理层                             │
│  eMPL/inv_mpu.c - 传感器融合、姿态解算                  │
│  ┌──────────────────────────────────────┐              │
│  │ 1. 陀螺仪零偏校准                    │              │
│  │ 2. 传感器数据融合                    │              │
│  │ 3. 姿态解算（四元数）                │              │
│  │ 4. FIFO输出                          │              │
│  └──────────────────────────────────────┘              │
└─────────────────────────────────────────────────────────┘
        │
        │ 四元数(q30格式)
        ↓
┌─────────────────────────────────────────────────────────┐
│               坐标转换层（inv_mpu.c）                     │
│  四元数 → 欧拉角转换                                      │
│  - q0,q1,q2,q3 → pitch, roll, yaw                       │
│  - 单位：q30定点数 → 度                                  │
└─────────────────────────────────────────────────────────┘
        │
        │ 欧拉角（度）
        ↓
┌─────────────────────────────────────────────────────────┐
│              应用封装层（imu_data.c）                    │
│  ┌──────────────────────────────────────┐              │
│  │ 1. 数据格式转换                      │              │
│  │    - 陀螺仪：原始值 → 弧度/秒        │              │
│  │    - 加速度：原始值 → G              │              │
│  │ 2. 精度处理                          │              │
│  │    - 所有数据放大100倍               │              │
│  │ 3. 统一接口                          │              │
│  └──────────────────────────────────────┘              │
└─────────────────────────────────────────────────────────┘
        │
        │ 标准化数据（放大100倍）
        ↓
┌─────────────────────────────────────────────────────────┐
│                  上层应用                                 │
│  底盘控制、姿态平衡、运动解算                            │
└─────────────────────────────────────────────────────────┘
```

### 6.2 典型使用场景

#### 场景1：底盘姿态平衡控制

```c
// 初始化
IMU_Init();

// 控制循环（10ms周期）
while(1) {
    // 更新IMU数据
    IMU_Update();

    // 获取姿态角
    int16_t euler[3];
    IMU_GetEulerAngle(euler);

    float pitch = euler[0] / 100.0f;  // 俯仰角（度）
    float roll = euler[1] / 100.0f;   // 横滚角（度）

    // 姿态控制
    if (pitch > 5.0) {
        // 前倾，减速或后退
    } else if (pitch < -5.0) {
        // 后仰，加速或前进
    }

    HAL_Delay(10);
}
```

#### 场景2：角速度积分辅助

```c
// 获取陀螺仪数据
int16_t gyro[3];
IMU_GetGyro(gyro);

float gyro_x = gyro[0] / 100.0f;  // 弧度/秒

// 角速度积分（用于短期预测）
static float estimated_pitch = 0;
estimated_pitch += gyro_x * 0.01;  // 10ms周期

// 与DMP输出融合
float dmp_pitch = euler[0] / 100.0f;
float fused_pitch = 0.95 * dmp_pitch + 0.05 * estimated_pitch;
```

#### 场景3：加速度监控

```c
// 获取加速度数据
int16_t acc[3];
IMU_GetAccel(acc);

float accel_x = acc[0] / 100.0f * 9.8f;  // m/s²
float accel_y = acc[1] / 100.0f * 9.8f;
float accel_z = acc[2] / 100.0f * 9.8f;

// 计算总加速度（排除重力）
float accel_magnitude = sqrt(accel_x*accel_x + accel_y*accel_y);

if (accel_magnitude > 2.0) {
    // 检测到冲击或急转弯
}
```

### 6.3 数据精度分析

| 数据类型 | 原始精度 | 转换后精度 | 放大后精度 | 实际分辨率 |
|---------|---------|----------|----------|----------|
| 陀螺仪 | 16位ADC | 0.001064 rad/s | ×100 | 0.00001064 rad/s |
| 加速度 | 16位ADC | 0.000061 G | ×100 | 0.00000061 G |
| 欧拉角 | 浮点 | 0.1° | ×100 | 0.001° |

**误差源**：
1. **传感器噪声**：随机噪声，通过滤波减少
2. **零偏漂移**：DMP自动校准
3. **温度漂移**：DMP有温度补偿
4. **量化误差**：ADC分辨率限制
5. **安装误差**：通过方向矩阵校正

---

## 7. 配置参数总结

### 7.1 关键配置参数

| 参数 | 值 | 说明 | 修改影响 |
|-----|---|-----|---------|
| I2C地址 | 0x68 | 硬件地址 | 改变AD0引脚接法 |
| 陀螺仪量程 | ±2000dps | GYRO_CFG_REG=0x18 | 改变灵敏度 |
| 加速度计量程 | ±2G | ACCEL_CFG_REG=0x00 | 改变灵敏度 |
| 采样率 | 100Hz | DEFAULT_MPU_HZ=100 | DMP输出速率，影响数据更新速度 |
| DLPF | 42Hz | CFG_REG=4 | 影响噪声过滤 |
| DMP输出率 | 100Hz | DEFAULT_MPU_HZ=100 | 姿态数据更新率 |

### 7.2 性能参数

| 参数 | 值 | 说明 |
|-----|---|-----|
| 姿态更新率 | 100Hz | 每10ms一次 |
| 延迟 | <10ms | 从传感器到输出 |
| 功耗 | 约4mA | 正常工作模式 |
| 精度（静态） | ±1° | 欧拉角精度 |
| 精度（动态） | ±2-3° | 运动状态下 |

---

## 8. 常见问题与调试

### 8.1 初始化失败

**错误码对应**：
```c
0: 成功
1: 传感器启用失败
2: FIFO配置失败
3: 采样率设置失败
4: DMP固件加载失败 ⚠️ 最常见
5: 方向矩阵设置失败
6: DMP功能启用失败
7: FIFO速率设置失败
8: 自检失败
9: DMP使能失败
10: MPU硬件初始化失败
```

**排查步骤**：
1. 检查I2C连接（示波器查看SCL/SDA波形）
2. 验证器件ID读取是否正确（应为0x68）
3. 检查电源供电是否稳定
4. 确认AD0引脚接法

### 8.2 数据异常

**现象**：角度值跳变、漂移

**原因**：
1. 供电不稳定
2. 机械振动过大
3. 温度变化剧烈
4. DMP未完全初始化

**解决**：
1. 增加电源滤波电容
2. 调整DLPF参数
3. 等待DMP稳定后再使用（上电后几百ms）

### 8.3 性能优化

**降低CPU占用**：
```c
// 使用中断方式读取FIFO
// 配置INT引脚到STM32外部中断
// 在中断中读取数据
```

**提高精度**：
```c
// 启用更多的DMP功能
// 增加DMP_FEATURE_GYRO_CAL
// 定期运行自检
```

---

## 9. 总结

### 9.1 架构优势

1. **分层清晰**：硬件、驱动、算法、应用分离
2. **职责明确**：每层专注特定功能
3. **易于维护**：修改一层不影响其他层
4. **可移植性强**：eMPL库可用于其他平台

### 9.2 DMP的核心价值

1. **硬件加速**：解放MCU资源
2. **算法成熟**：InvenSense专利算法
3. **自动校准**：减少维护成本
4. **低延迟**：实时性能好

### 9.3 应用建议

1. **定期更新**：每10-20ms调用一次`IMU_Update()`
2. **数据验证**：检查角度值是否合理
3. **异常处理**：初始化失败时重试
4. **校准维护**：长期使用后可重新校准

---

## 参考资源

- **MPU6050数据手册**：[Register Map and Descriptions](https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Register-Map1.pdf)
- **eMPL库文档**：InvenSense官方库
- **四元数教程**：3D数学基础资料
- **I2C协议**：I2C总线规范

---

**文档版本**：v1.1
**更新日期**：2026-01-24
**适用项目**：RobotChassis_Firmware
**作者**：基于代码分析整理
**更新说明**：更新为100Hz DMP输出，添加中断驱动模式说明
