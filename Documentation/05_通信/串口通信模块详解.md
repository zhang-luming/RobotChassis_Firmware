# 串口通信模块详解

## 模块概述

串口通信模块负责MCU与上位机之间的数据通信，实现控制指令接收和传感器数据上报功能。

**核心特性**：
- 中断驱动的非阻塞接收机制
- 固定12字节协议帧格式
- XOR校验保证数据完整性
- 双串口架构（调试+通信）

---

## 硬件配置

### 串口资源

| 串口 | 引脚 | 波特率 | 用途 |
|------|------|--------|------|
| **USART1** | PA9(TX), PA10(RX) | 115200 | 调试输出（printf） |
| **USART2** | PA2(TX), PA3(RX) | 115200 | 数据通信（协议） |

### 中断配置

```
USART2中断:
- 优先级: 0,0 (最高)
- 触发方式: 接收完成中断
- 处理函数: HAL_UART_RxCpltCallback() → Comm_RxCallback()
```

---

## 协议帧格式

### 固定帧结构

```
┌──────┬──────────┬────────────────────┬──────────┬──────┐
│ 帧头 │  功能码  │      数据区         │  校验码  │ 帧尾  │
│ 1B   │   1B     │       8B           │   1B     │  1B  │
└──────┴──────────┴────────────────────┴──────────┴──────┘
 0xFC    0x01-0x08   具体功能相关         XOR       0xDF
```

### 字节说明

| 字节偏移 | 内容 | 说明 |
|----------|------|------|
| 0 | 0xFC | 帧头（固定） |
| 1 | 功能码 | 0x01-0x08，见功能码表 |
| 2-9 | 数据区 | 8字节数据，大端序 |
| 10 | XOR校验 | 字节0-9的异或校验 |
| 11 | 0xDF | 帧尾（固定） |

### 校验码计算

```python
def calculate_checksum(frame_bytes):
    """计算XOR校验码（包含帧头和功能码）"""
    checksum = 0
    for i in range(10):  # 字节0-9
        checksum ^= frame_bytes[i]
    return checksum
```

---

## 功能码定义

| 功能码 | 名称 | 方向 | 数据格式 | 说明 |
|--------|------|------|----------|------|
| 0x01 | 电池电压 | MCU→上位机 | `[0][0][v高][v低][0×4]` | 电压值(mV) |
| 0x02 | 编码器 | MCU→上位机 | `[A高][A低][B高][B低][C高][C低][D高][D低]` | 编码器累加值 |
| 0x03 | 陀螺仪 | MCU→上位机 | `[X高][X低][Y高][Y低][Z高][Z低][0×2]` | 0.01弧度/s |
| 0x04 | 加速度 | MCU→上位机 | `[X高][X低][Y高][Y低][Z高][Z低][0×2]` | 0.01G |
| 0x05 | 欧拉角 | MCU→上位机 | `[P高][P低][R高][R低][Y高][Y低][0×2]` | 0.01度 |
| 0x06 | 电机控制 | 上位机→MCU | `[A高][A低][B高][B低][C高][C低][D高][D低]` | centi-CPS |
| 0x07 | PID参数 | 上位机→MCU | `[Kp高][Kp低][Ki高][Ki低][Kd高][Kd低][0×2]` | 参数×100 |
| 0x08 | 舵机控制 | 上位机→MCU | `[角度1][0][角度2][0][0×4]` | 0-180度 |

---

## 接收机制

### 中断驱动接收

```c
// USER/Communication/comm_protocol.c

void Comm_Init(void) {
    memset(g_comm_rx.buffer, 0, sizeof(g_comm_rx.buffer));
    g_comm_rx.index = 0;
    g_comm_rx.complete = 0;

    // 启动串口接收中断（单字节模式）
    HAL_UART_Receive_IT(&huart2, &g_comm_rx.byte, 1);
}

// HAL库中断回调
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == USART2) {
        Comm_RxCallback(huart);  // 调用协议处理函数
    }
}
```

### 状态机接收流程

```
接收状态机:
┌──────────┐
│ 等待帧头 │ (检查 0xFC)
└────┬─────┘
     ↓
┌──────────┐
│ 等待功能码 │ (检查 0x06/0x07/0x08)
└────┬─────┘
     ↓
┌──────────┐
│ 接收数据区 │ (接收8字节)
└────┬─────┘
     ↓
┌──────────┐
│ 接收校验码 │ (XOR校验)
└────┬─────┘
     ↓
┌──────────┐
│ 等待帧尾 │ (检查 0xDF)
└────┬─────┘
     ↓
┌──────────┐
│ 接收完成 │ (设置 complete=1)
└──────────┘
```

### 接收状态结构

```c
typedef struct {
    uint8_t buffer[RX_BUFFER_SIZE];  // 接收缓冲区（256字节）
    uint8_t index;                   // 当前接收索引
    uint8_t byte;                    // 单字节接收缓冲
    uint8_t complete;                // 接收完成标志
} CommRx_t;
```

---

## 数据分发

### 主循环处理

```c
// Core/Src/main.c

void main(void) {
    // ...初始化...

    while (1) {
        if (timer_10ms_flag) {
            timer_10ms_flag = 0;

            LED_Update();              // LED更新
            Comm_Update();             // 通信数据处理 ← 每个周期调用
            Motor_Update();            // 电机控制
            // ...
        }
    }
}
```

### 指令分发逻辑

```c
// USER/Communication/comm_protocol.c:56

void Comm_Update(void) {
    if (g_comm_rx.complete == 1) {
        uint8_t func_code = g_comm_rx.buffer[1];  // 获取功能码

        switch (func_code) {
            case FUNC_SERVO_CONTROL:  // 0x08 - 舵机控制
                Servo_ProcessSetAngle(0, g_comm_rx.buffer[2]);
                Servo_ProcessSetAngle(1, g_comm_rx.buffer[3]);
                break;

            case FUNC_MOTOR_SPEED:  // 0x06 - 电机速度
                speed[0] = (int16_t)((g_comm_rx.buffer[2] << 8) | g_comm_rx.buffer[3]);
                speed[1] = (int16_t)((g_comm_rx.buffer[4] << 8) | g_comm_rx.buffer[5]);
                speed[2] = (int16_t)((g_comm_rx.buffer[6] << 8) | g_comm_rx.buffer[7]);
                speed[3] = (int16_t)((g_comm_rx.buffer[8] << 8) | g_comm_rx.buffer[9]);

                Motor_ProcessSetSpeed(0, speed[0]);
                Motor_ProcessSetSpeed(1, speed[1]);
                Motor_ProcessSetSpeed(2, speed[2]);
                Motor_ProcessSetSpeed(3, speed[3]);
                break;

            case FUNC_PID_PARAM:  // 0x07 - PID参数
                kp = (int16_t)((g_comm_rx.buffer[2] << 8) | g_comm_rx.buffer[3]);
                ki = (int16_t)((g_comm_rx.buffer[4] << 8) | g_comm_rx.buffer[5]);
                kd = (int16_t)((g_comm_rx.buffer[6] << 8) | g_comm_rx.buffer[7]);

                for (uint8_t i = 0; i < 4; i++) {
                    Motor_ProcessSetPID(i, kp, ki, kd);
                }
                break;
        }

        g_comm_rx.complete = 0;  // 清除完成标志
    }
}
```

---

## 数据发送

### 发送接口

```c
// USER/Communication/comm_protocol.h

void Comm_SendEulerAngle(int16_t *euler_angle);    // 发送欧拉角
void Comm_SendGyro(int16_t *gyro);                 // 发送陀螺仪
void Comm_SendAccel(int16_t *acc);                 // 发送加速度
void Comm_SendEncoder(int16_t *encoder);           // 发送编码器
void Comm_SendBatteryVoltage(uint16_t voltage);    // 发送电池电压
```

### 发送流程

```c
// USER/Communication/comm_protocol.c:208

void Comm_SendEulerAngle(int16_t *euler_angle) {
    UART_SEND_BUF[0] = PROTOCOL_HEADER;           // 0xFC
    UART_SEND_BUF[1] = FUNC_EULER_ANGLE;          // 0x05

    // 数据打包（大端序）
    UART_SEND_BUF[2] = euler_angle[0] >> 8;       // 俯仰角高位
    UART_SEND_BUF[3] = euler_angle[0] & 0x00FF;   // 俯仰角低位
    UART_SEND_BUF[4] = euler_angle[1] >> 8;       // 横滚角高位
    UART_SEND_BUF[5] = euler_angle[1] & 0x00FF;   // 横滚角低位
    UART_SEND_BUF[6] = euler_angle[2] >> 8;       // 航向角高位
    UART_SEND_BUF[7] = euler_angle[2] & 0x00FF;   // 航向角低位
    UART_SEND_BUF[8] = 0x00;                      // 保留
    UART_SEND_BUF[9] = 0x00;                      // 保留

    // 校验码（字节0-9的XOR）
    UART_SEND_BUF[10] = Comm_XORCheck(UART_SEND_BUF, 10);
    UART_SEND_BUF[11] = PROTOCOL_TAIL;            // 0xDF

    // 发送（阻塞模式）
    Comm_SendBuf(USART2, UART_SEND_BUF, 12);
}
```

### 发送时序

```
IMU中断触发 (100Hz)
    ↓
IMU_Update() → 读取DMP数据
    ↓
IMU_Send() → 调用Comm_Send*()
    ↓
USART2发送（阻塞，约1ms）
    ↓
发送完成，返回
```

---

## 通信时序

### 典型通信流程

```
上位机发送控制指令:
[FC][06][speed_A...][checksum][DF]  →  USART2接收中断
                                        ↓
                                    Comm_RxCallback()
                                        ↓
                                    g_comm_rx.complete = 1
                                        ↓
                                    主循环检测到complete标志
                                        ↓
                                    Comm_Update() 分发指令
                                        ↓
                                    Motor_SetSpeed() / Servo_SetAngle()

MCU主动上报数据:
MPU INT中断 (100Hz)
    ↓
IMU_Update()
    ↓
IMU_Send() → Comm_SendEulerAngle()
    ↓
USART2发送: [FC][05][pitch...][checksum][DF]
```

### 时序特性

| 操作 | 触发频率 | 执行时间 | 方式 |
|------|----------|----------|------|
| 指令接收 | 按需 | <1us/字节 | 中断驱动 |
| 指令处理 | 100Hz | <100us | 主循环轮询 |
| IMU数据上报 | 100Hz | ~1ms | 中断直接发送 |
| 编码器上报 | 25Hz | ~1ms | 主循环发送 |

---

## 常见问题

### Q1: 为什么数据没有接收？

**检查项**：
1. 确认USART2中断已使能：`HAL_UART_Receive_IT(&huart2, &g_comm_rx.byte, 1)`
2. 确认波特率为115200
3. 确认帧头为0xFC
4. 检查 `Comm_Update()` 是否在主循环中调用

### Q2: 校验码错误

**原因**：
- 计算范围错误（应该包括字节0-9，包含帧头）
- 字节序错误（应使用大端序）

**正确计算**：
```python
checksum = 0
for i in range(10):  # 注意：只计算前10个字节
    checksum ^= frame[i]
```

### Q3: 数据未及时处理

**原因**：
- `Comm_Update()` 未在主循环中调用
- `g_comm_rx.complete` 标志未清除

**解决**：
```c
// 在主循环中每10ms调用
if (timer_10ms_flag) {
    Comm_Update();  // 处理通信数据
    // ...
}
```

---

## 调试技巧

### printf重定向

```c
// Core/Src/main.c

int main(void) {
    // ...
    RetargetInit(&huart1);  // printf重定向到USART1

    printf("系统启动\r\n");  // 在USART1输出调试信息
    // ...
}
```

### 协议测试

```python
# Python测试脚本示例

import serial
import struct

ser = serial.Serial('/dev/ttyUSB0', 115200)

# 构建电机控制指令
def build_motor_command(speed_a, speed_b, speed_c, speed_d):
    data = bytearray([0xFC, 0x06])
    for speed in [speed_a, speed_b, speed_c, speed_d]:
        data.extend(struct.pack('>h', speed))  # 大端序int16

    checksum = 0
    for i in range(10):
        checksum ^= data[i]
    data.append(checksum)
    data.append(0xDF)
    return bytes(data)

# 发送指令
cmd = build_motor_command(500, 500, 500, 500)
ser.write(cmd)
```

---

## 参考资料

- `USER/Communication/comm_protocol.h` - 协议定义和接口
- `USER/Communication/comm_protocol.c` - 协议实现
- `Core/Src/usart.c` - 串口硬件配置
- `04_电机/电机控制模块详解.md` - 电机控制协议说明

---

**文档版本**: 1.0
**最后更新**: 2026-01-24
