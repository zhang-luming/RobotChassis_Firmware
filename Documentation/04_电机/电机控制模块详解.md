# 电机控制模块

## 模块功能

四路电机PID闭环速度控制，支持编码器反馈和PWM输出。

---

## 接口说明

### 初始化和控制

```c
void Motor_Init(void);          // 初始化电机模块
void Motor_Update(void);        // 每个控制周期调用（10ms）
void Motor_Send(void);          // 发送编码器数据到上位机
```

### 速度控制

```c
// 设置电机目标速度
void Motor_ProcessSetSpeed(uint8_t motor_id, int16_t speed);

// 设置PID参数
void Motor_ProcessSetPID(uint8_t motor_id, int16_t kp, int16_t ki, int16_t kd);
```

**参数说明：**
- `motor_id`: 电机ID（0=A, 1=B, 2=C, 3=D）
- `speed`: 目标速度，单位 **centi-CPS**（CPS/100）

---

## 速度单位

### centi-CPS 定义

**centi-CPS = CPS / 100**（编码器计数/秒 ÷ 100）

| 协议值 | 实际CPS | 10ms增量 |
|--------|---------|----------|
| 10     | 1000    | 10       |
| 100    | 10000   | 100      |
| 500    | 50000   | 500      |
| 1000   | 100000  | 1000     |

### RPM 转换

```
协议值 = RPM × (PPR × 4 × 减速比) / 60 / 100
```

**示例（PPR=500，减速比30:1）：**

| 目标RPM | 协议值 | 实际CPS |
|---------|--------|---------|
| 10     | 100    | 10000   |
| 50     | 500    | 50000   |
| 100    | 1000   | 100000  |

---

## 通信协议

### 协议帧格式

**所有协议帧固定12字节：**

```
[帧头][功能码][数据8字节][校验][帧尾]
  1B    1B      8B      1B    1B
```

| 字节 | 内容 | 说明 |
|------|------|------|
| 0    | 0xFC | 帧头 |
| 1    | 功能码 | 0x02=编码器, 0x06=电机控制, 0x07=PID设置 |
| 2-9  | 数据 | 具体内容见下文 |
| 10   | 校验码 | XOR校验（字节0-9，包含帧头） |
| 11   | 0xDF | 帧尾 |

### 校验码计算

```python
# 校验范围：字节0-9（包含帧头和功能码）
checksum = 0
for byte in [0xFC, 功能码, 数据字节0-7]:
    checksum ^= byte
```

---

## MCU上报：编码器数据

### 帧格式（功能码 0x02）

```
[FC][02][A高][A低][B高][B低][C高][C低][D高][D低][校验][DF]
```

**数据内容：**
- 字节2-9：四个电机的编码器累加值（int16_t，大端序）
- 单位：编码器计数（累加值，非速度）

### 上位机解析示例

```python
def parse_encoder_data(frame):
    """解析编码器数据帧"""
    if len(frame) != 12 or frame[0] != 0xFC or frame[1] != 0x02:
        return None

    # 校验
    checksum = 0
    for i in range(10):
        checksum ^= frame[i]
    if checksum != frame[10]:
        return None

    # 提取数据（大端序）
    encoder = []
    for i in range(4):
        high = frame[2 + i*2]
        low = frame[3 + i*2]
        value = (high << 8) | low
        # 转换为有符号整数
        if value >= 32768:
            value -= 65536
        encoder.append(value)

    return encoder  # [A, B, C, D]

# 示例
frame = bytes.fromhex('FC 02 00 10 00 20 00 30 00 40 XX DF')
encoders = parse_encoder_data(frame)
print(f"编码器值: A={encoders[0]}, B={encoders[1]}, C={encoders[2]}, D={encoders[3]}")
```

---

## 上位机下发：电机控制

### 帧格式（功能码 0x06）

```
[FC][06][A高][A低][B高][B低][C高][C低][D高][D低][校验][DF]
```

**数据内容：**
- 字节2-9：四个电机的目标速度（int16_t，大端序）
- 单位：**centi-CPS**（CPS/100）

### 发送示例

```python
def build_motor_command(speed_a, speed_b, speed_c, speed_d):
    """
    构建电机控制指令

    参数：speed_a-d 为 centi-CPS 值
    返回：12字节协议帧
    """
    data = bytearray([0xFC, 0x06])

    # 添加四个电机速度（大端序）
    for speed in [speed_a, speed_b, speed_c, speed_d]:
        data.append((speed >> 8) & 0xFF)
        data.append(speed & 0xFF)

    # 计算校验（包含帧头FC）
    checksum = 0
    for byte in data:  # data已经包含FC和06
        checksum ^= byte
    data.append(checksum)

    data.append(0xDF)
    return bytes(data)

# 示例1：停止所有电机
frame = build_motor_command(0, 0, 0, 0)
print(' '.join([f'{b:02X}' for b in frame]))
# 输出: FC 06 00 00 00 00 00 00 00 00 FA DF

# 示例2：50 RPM（PPR=500，减速比30:1 → 协议值500）
frame = build_motor_command(500, 500, 500, 500)
print(' '.join([f'{b:02X}' for b in frame]))
# 输出: FC 06 01 F4 01 F4 01 F4 01 F4 FA DF
```

### 从RPM转换

```python
def rpm_to_centi_cps(rpm, ppr, gear_ratio):
    """RPM转换为centi-CPS"""
    cps = rpm * ppr * 4 * gear_ratio / 60
    return int(cps / 100)

# 使用示例
ppr = 500
gear_ratio = 30
target_rpm = 50

centi_cps = rpm_to_centi_cps(target_rpm, ppr, gear_ratio)
frame = build_motor_command(centi_cps, centi_cps, centi_cps, centi_cps)
ser.write(frame)  # 发送到串口
```

---

## 上位机下发：PID参数

### 帧格式（功能码 0x07）

```
[FC][07][Kp高][Kp低][Ki高][Ki低][Kd高][Kd低][00][00][校验][DF]
```

**数据内容：**
- 字节2-3：Kp参数（放大100倍，大端序）
- 字节4-5：Ki参数（放大100倍，大端序）
- 字节6-7：Kd参数（放大100倍，大端序）
- 字节8-9：保留（00 00）

**注意：** MCU会将此参数应用到所有4个电机

### 发送示例

```python
def build_pid_command(kp, ki, kd):
    """
    构建PID参数设置指令

    参数：Kp, Ki, Kd 已经放大100倍
    返回：12字节协议帧
    """
    data = bytearray([0xFC, 0x07])

    # 添加PID参数（大端序）
    for param in [kp, ki, kd]:
        data.append((param >> 8) & 0xFF)
        data.append(param & 0xFF)

    # 保留字节
    data.extend([0x00, 0x00])

    # 计算校验
    checksum = 0
    for byte in data:
        checksum ^= byte
    data.append(checksum)

    data.append(0xDF)
    return bytes(data)

# 示例：设置 Kp=1.0, Ki=0.2, Kd=0.0
# 参数放大100倍：Kp=100, Ki=20, Kd=0
frame = build_pid_command(100, 20, 0)
print(' '.join([f'{b:02X}' for b in frame]))
# 输出: FC 07 00 64 00 14 00 00 00 00 XX DF
```

---

## 快速参考

### 数据范围

- **协议值范围**：-32768 到 32767（int16_t）
- **实际CPS范围**：-3276800 到 3276700 CPS
- **足够覆盖大部分应用**

### PID参数参考

| 场景 | Kp | Ki | Kd |
|------|----|----|----|
| 低速高精度 | 30-50 | 5-10 | 0 |
| 中速通用 | 100 | 20 | 0 |
| 快速响应 | 200-300 | 50-100 | 0-5 |

**注意：** PID参数已放大100倍，例如 Kp=1.0 应发送 100

### 工具脚本

```bash
# 使用centi-CPS值
python Tools/generate_motor_command.py 500 500 500 500

# 从RPM转换（需要指定PPR和减速比）
python Tools/generate_motor_command_with_rpm.py 50 50 50 50 500 30
```

---

## 版本历史

| 版本 | 日期 | 说明 |
|------|------|------|
| v2.1 | 2025-01-18 | 改用centi-CPS单位，补充收发协议详解 |
